from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Protocol

from .entities import Chat, ChatMessage, DatasetSnapshot, Document, EvaluationResult, GroundTruth, SearchResult, User


class DocumentRepositoryPort(Protocol):
    def upsert_documents(self, documents: list[Document]) -> int: ...
    def count_by_dataset(self, dataset: str) -> int: ...
    def search_by_embedding(self, dataset: str, query_vector: list[float], top_k: int) -> list[SearchResult]: ...
    def search_by_quantum(self, dataset: str, query_vector: list[float], top_k: int) -> list[SearchResult]: ...
    def list_document_ids(self, dataset: str) -> list[str]: ...


class GroundTruthRepositoryPort(Protocol):
    def upsert(self, item: GroundTruth) -> GroundTruth: ...
    def upsert_qrels(self, dataset: str, split: str, query_id: str, query_text: str, qrels: dict[str, int]) -> None: ...
    def get(self, dataset: str, query_id: str) -> GroundTruth | None: ...
    def list_by_dataset(self, dataset: str) -> list[GroundTruth]: ...
    def delete(self, dataset: str, query_id: str) -> bool: ...


class DatasetSnapshotRepositoryPort(Protocol):
    def upsert(self, item: DatasetSnapshot) -> DatasetSnapshot: ...
    def get(self, dataset_id: str) -> DatasetSnapshot | None: ...
    def list_all(self) -> list[DatasetSnapshot]: ...


class UserRepositoryPort(Protocol):
    def create(self, user: User) -> User: ...
    def get_by_email(self, email: str) -> User | None: ...
    def get_by_id(self, user_id: int) -> User | None: ...
    def update_password_hash(self, user_id: int, password_hash: str) -> None: ...


class PasswordResetRepositoryPort(Protocol):
    def create(self, user_id: int, token_hash: str, expires_at: datetime) -> None: ...
    def consume_valid(self, token_hash: str, now: datetime) -> int | None: ...


class ChatRepositoryPort(Protocol):
    def create_chat(self, chat: Chat) -> Chat: ...
    def list_chats(self, user_id: int, offset: int, limit: int) -> list[Chat]: ...
    def get_chat(self, user_id: int, chat_id: int) -> Chat | None: ...
    def rename_chat(self, user_id: int, chat_id: int, title: str) -> Chat | None: ...
    def soft_delete_chat(self, user_id: int, chat_id: int) -> bool: ...
    def create_message(self, message: ChatMessage) -> ChatMessage: ...
    def list_messages(self, user_id: int, chat_id: int, offset: int, limit: int) -> list[ChatMessage]: ...


class PasswordHasherPort(Protocol):
    def hash(self, password: str) -> str: ...
    def verify(self, password: str, password_hash: str) -> bool: ...


class JwtProviderPort(Protocol):
    def create_access_token(self, subject: str, extra_claims: dict[str, str] | None = None) -> str: ...
    def create_refresh_token(self, subject: str) -> str: ...
    def decode_token(self, token: str) -> dict[str, str]: ...


class ResetTokenGeneratorPort(Protocol):
    def generate(self) -> str: ...
    def hash(self, token: str) -> str: ...


class NotificationPort(Protocol):
    def send_password_reset(self, email: str, token: str) -> None: ...


class EncoderPort(Protocol):
    dim: int
    def encode(self, text: str) -> list[float]: ...


@dataclass(slots=True)
class EvaluationAggregate:
    pipeline: str
    k: int
    per_query: list[EvaluationResult]
    mean_precision_at_k: float
    mean_recall_at_k: float
    mean_ndcg_at_k: float
    mean_spearman: float


class MetricsPort(Protocol):
    def evaluate_query(
        self,
        *,
        query_id: str | None,
        query_text: str,
        pipeline: str,
        retrieved_doc_ids: list[str],
        retrieved_scores: list[float],
        relevant_doc_ids: list[str],
        k: int,
    ) -> EvaluationResult: ...


class DatasetProviderPort(Protocol):
    def list_datasets(self) -> list[dict]: ...
    def get_dataset(self, dataset_id: str) -> dict | None: ...
    def iter_documents(self, dataset_id: str): ...
    def iter_queries(self, dataset_id: str): ...
